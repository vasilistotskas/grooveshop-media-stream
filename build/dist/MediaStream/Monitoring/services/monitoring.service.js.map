{"version":3,"sources":["../../../../../src/MediaStream/Monitoring/services/monitoring.service.ts"],"sourcesContent":["import type {\r\n\tComponentHealth,\r\n\tCustomMetric,\r\n\tMonitoringConfig,\r\n\tSystemHealth,\r\n} from '../interfaces/monitoring.interface'\r\nimport * as process from 'node:process'\r\nimport { CorrelationService } from '@microservice/Correlation/services/correlation.service'\r\nimport { Injectable, Logger } from '@nestjs/common'\r\nimport { ConfigService } from '@nestjs/config'\r\nimport { MetricType } from '../interfaces/monitoring.interface'\r\n\r\n@Injectable()\r\nexport class MonitoringService {\r\n\tprivate readonly _logger = new Logger(MonitoringService.name)\r\n\tprivate readonly metrics = new Map<string, CustomMetric[]>()\r\n\tprivate readonly config: MonitoringConfig\r\n\tprivate readonly maxMetricsPerType = 10000\r\n\r\n\tconstructor(\r\n\t\tprivate readonly _configService: ConfigService,\r\n\t\tprivate readonly _correlationService: CorrelationService,\r\n\t) {\r\n\t\tthis.config = this._configService.get<MonitoringConfig>('monitoring', {\r\n\t\t\tenabled: true,\r\n\t\t\tmetricsRetentionMs: 24 * 60 * 60 * 1000,\r\n\t\t\talertsRetentionMs: 7 * 24 * 60 * 60 * 1000,\r\n\t\t\tperformanceRetentionMs: 24 * 60 * 60 * 1000,\r\n\t\t\thealthCheckIntervalMs: 30 * 1000,\r\n\t\t\talertCooldownMs: 5 * 60 * 1000,\r\n\t\t\texternalIntegrations: {\r\n\t\t\t\tenabled: false,\r\n\t\t\t\tendpoints: [],\r\n\t\t\t},\r\n\t\t})\r\n\r\n\t\tif (this.config.enabled) {\r\n\t\t\tthis.startMetricsCleanup()\r\n\t\t\tthis._logger.log('Monitoring service initialized')\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Record a custom metric\r\n\t */\r\n\trecordMetric(name: string, value: number, type: MetricType, tags?: Record<string, string>): void {\r\n\t\tif (!this.config.enabled)\r\n\t\t\treturn\r\n\r\n\t\tconst metric: CustomMetric = {\r\n\t\t\tname,\r\n\t\t\tvalue,\r\n\t\t\ttimestamp: Date.now(),\r\n\t\t\ttags,\r\n\t\t\ttype,\r\n\t\t}\r\n\r\n\t\tif (!this.metrics.has(name)) {\r\n\t\t\tthis.metrics.set(name, [])\r\n\t\t}\r\n\r\n\t\tconst metricsList = this.metrics.get(name)!\r\n\t\tmetricsList.push(metric)\r\n\r\n\t\tif (metricsList.length > this.maxMetricsPerType) {\r\n\t\t\tmetricsList.splice(0, metricsList.length - this.maxMetricsPerType)\r\n\t\t}\r\n\r\n\t\tthis._logger.debug(`Recorded metric: ${name} = ${value}`, {\r\n\t\t\tcorrelationId: this._correlationService.getCorrelationId(),\r\n\t\t\tmetric,\r\n\t\t})\r\n\t}\r\n\r\n\t/**\r\n\t * Record a counter metric (incremental value)\r\n\t */\r\n\tincrementCounter(name: string, value: number = 1, tags?: Record<string, string>): void {\r\n\t\tthis.recordMetric(name, value, MetricType.COUNTER, tags)\r\n\t}\r\n\r\n\t/**\r\n\t * Record a gauge metric (current value)\r\n\t */\r\n\trecordGauge(name: string, value: number, tags?: Record<string, string>): void {\r\n\t\tthis.recordMetric(name, value, MetricType.GAUGE, tags)\r\n\t}\r\n\r\n\t/**\r\n\t * Record a histogram metric (distribution of values)\r\n\t */\r\n\trecordHistogram(name: string, value: number, tags?: Record<string, string>): void {\r\n\t\tthis.recordMetric(name, value, MetricType.HISTOGRAM, tags)\r\n\t}\r\n\r\n\t/**\r\n\t * Record a timer metric (duration)\r\n\t */\r\n\trecordTimer(name: string, durationMs: number, tags?: Record<string, string>): void {\r\n\t\tthis.recordMetric(name, durationMs, MetricType.TIMER, tags)\r\n\t}\r\n\r\n\t/**\r\n\t * Get metrics by name\r\n\t */\r\n\tgetMetrics(name: string, since?: number): CustomMetric[] {\r\n\t\tconst metrics = this.metrics.get(name) || []\r\n\t\tif (since) {\r\n\t\t\treturn metrics.filter(m => m.timestamp >= since)\r\n\t\t}\r\n\t\treturn [...metrics]\r\n\t}\r\n\r\n\t/**\r\n\t * Get all metric names\r\n\t */\r\n\tgetMetricNames(): string[] {\r\n\t\treturn Array.from(this.metrics.keys())\r\n\t}\r\n\r\n\t/**\r\n\t * Get aggregated metrics for a time period\r\n\t */\r\n\tgetAggregatedMetrics(name: string, since: number): {\r\n\t\tcount: number\r\n\t\tsum: number\r\n\t\tavg: number\r\n\t\tmin: number\r\n\t\tmax: number\r\n\t\tlatest: number\r\n\t} {\r\n\t\tconst metrics = this.getMetrics(name, since)\r\n\t\tif (metrics.length === 0) {\r\n\t\t\treturn {\r\n\t\t\t\tcount: 0,\r\n\t\t\t\tsum: 0,\r\n\t\t\t\tavg: 0,\r\n\t\t\t\tmin: 0,\r\n\t\t\t\tmax: 0,\r\n\t\t\t\tlatest: 0,\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst values = metrics.map(m => m.value)\r\n\t\tconst sum = values.reduce((a: any, b: any) => a + b, 0)\r\n\r\n\t\treturn {\r\n\t\t\tcount: metrics.length,\r\n\t\t\tsum,\r\n\t\t\tavg: sum / metrics.length,\r\n\t\t\tmin: Math.min(...values),\r\n\t\t\tmax: Math.max(...values),\r\n\t\t\tlatest: metrics[metrics.length - 1].value,\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Get system health overview\r\n\t */\r\n\tasync getSystemHealth(): Promise<SystemHealth> {\r\n\t\tconst components: ComponentHealth[] = []\r\n\t\tlet totalScore = 0\r\n\r\n\t\tconst memoryHealth = await this.checkMemoryHealth()\r\n\t\tconst diskHealth = await this.checkDiskHealth()\r\n\t\tconst networkHealth = await this.checkNetworkHealth()\r\n\t\tconst cacheHealth = await this.checkCacheHealth()\r\n\r\n\t\tcomponents.push(memoryHealth, diskHealth, networkHealth, cacheHealth)\r\n\r\n\t\ttotalScore = components.reduce((sum: any, comp: any) => sum + comp.score, 0) / components.length\r\n\r\n\t\tlet status: 'healthy' | 'degraded' | 'unhealthy'\r\n\t\tif (totalScore >= 70) {\r\n\t\t\tstatus = 'healthy'\r\n\t\t}\r\n\t\telse if (totalScore >= 50) {\r\n\t\t\tstatus = 'degraded'\r\n\t\t}\r\n\t\telse {\r\n\t\t\tstatus = 'unhealthy'\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tstatus,\r\n\t\t\ttimestamp: Date.now(),\r\n\t\t\tcomponents,\r\n\t\t\toverallScore: totalScore,\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Get monitoring statistics\r\n\t */\r\n\tgetStats(): {\r\n\t\ttotalMetrics: number\r\n\t\tmetricTypes: Record<string, number>\r\n\t\toldestMetric: number\r\n\t\tnewestMetric: number\r\n\t\tmemoryUsage: number\r\n\t} {\r\n\t\tlet totalMetrics = 0\r\n\t\tlet oldestTimestamp = Date.now()\r\n\t\tlet newestTimestamp = 0\r\n\t\tconst metricTypes: Record<string, number> = {}\r\n\r\n\t\tfor (const [_name, metrics] of this.metrics.entries()) {\r\n\t\t\ttotalMetrics += metrics.length\r\n\t\t\tfor (const metric of metrics) {\r\n\t\t\t\tmetricTypes[metric.type] = (metricTypes[metric.type] || 0) + 1\r\n\t\t\t\toldestTimestamp = Math.min(oldestTimestamp, metric.timestamp)\r\n\t\t\t\tnewestTimestamp = Math.max(newestTimestamp, metric.timestamp)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst avgMetricSize = 200\r\n\t\tconst memoryUsage = totalMetrics * avgMetricSize\r\n\r\n\t\treturn {\r\n\t\t\ttotalMetrics,\r\n\t\t\tmetricTypes,\r\n\t\t\toldestMetric: oldestTimestamp,\r\n\t\t\tnewestMetric: newestTimestamp,\r\n\t\t\tmemoryUsage,\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Clear old metrics based on retention policy\r\n\t */\r\n\tprivate startMetricsCleanup(): void {\r\n\t\tconst cleanupInterval = Math.min(this.config.metricsRetentionMs / 10, 60 * 60 * 1000)\r\n\t\tsetInterval(() => {\r\n\t\t\tthis.cleanupOldMetrics()\r\n\t\t}, cleanupInterval)\r\n\t}\r\n\r\n\tprivate cleanupOldMetrics(): void {\r\n\t\tconst cutoffTime = Date.now() - this.config.metricsRetentionMs\r\n\t\tlet removedCount = 0\r\n\r\n\t\tfor (const [name, metrics] of this.metrics.entries()) {\r\n\t\t\tconst originalLength = metrics.length\r\n\t\t\tconst filteredMetrics = metrics.filter(m => m.timestamp >= cutoffTime)\r\n\t\t\tif (filteredMetrics.length !== originalLength) {\r\n\t\t\t\tthis.metrics.set(name, filteredMetrics)\r\n\t\t\t\tremovedCount += originalLength - filteredMetrics.length\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (removedCount > 0) {\r\n\t\t\tthis._logger.debug(`Cleaned up ${removedCount} old metrics`)\r\n\t\t}\r\n\t}\r\n\r\n\tprivate async checkMemoryHealth(): Promise<ComponentHealth> {\r\n\t\tconst memUsage = process.memoryUsage()\r\n\t\tconst totalMB = memUsage.heapTotal / 1024 / 1024\r\n\t\tconst usedMB = memUsage.heapUsed / 1024 / 1024\r\n\t\tconst usagePercent = (usedMB / totalMB) * 100\r\n\r\n\t\tlet score = 100\r\n\t\tif (usagePercent > 98)\r\n\t\t\tscore = 20\r\n\t\telse if (usagePercent > 95)\r\n\t\t\tscore = 50\r\n\t\telse if (usagePercent > 90)\r\n\t\t\tscore = 70\r\n\t\telse if (usagePercent > 85)\r\n\t\t\tscore = 85\r\n\r\n\t\treturn {\r\n\t\t\tname: 'memory',\r\n\t\t\tstatus: score >= 60 ? 'healthy' : score >= 40 ? 'degraded' : 'unhealthy',\r\n\t\t\tscore,\r\n\t\t\tmetrics: {\r\n\t\t\t\ttotalMB,\r\n\t\t\t\tusedMB,\r\n\t\t\t\tusagePercent,\r\n\t\t\t},\r\n\t\t\tlastCheck: Date.now(),\r\n\t\t}\r\n\t}\r\n\r\n\tprivate async checkDiskHealth(): Promise<ComponentHealth> {\r\n\t\t// In a real implementation, you'd check actual disk usage\r\n\t\treturn {\r\n\t\t\tname: 'disk',\r\n\t\t\tstatus: 'healthy',\r\n\t\t\tscore: 90,\r\n\t\t\tmetrics: {\r\n\t\t\t\tusagePercent: 45,\r\n\t\t\t\tavailableGB: 100,\r\n\t\t\t},\r\n\t\t\tlastCheck: Date.now(),\r\n\t\t}\r\n\t}\r\n\r\n\tprivate async checkNetworkHealth(): Promise<ComponentHealth> {\r\n\t\t// In a real implementation, you'd check network connectivity\r\n\t\treturn {\r\n\t\t\tname: 'network',\r\n\t\t\tstatus: 'healthy',\r\n\t\t\tscore: 95,\r\n\t\t\tmetrics: {\r\n\t\t\t\tlatencyMs: 10,\r\n\t\t\t\tpacketsLost: 0,\r\n\t\t\t},\r\n\t\t\tlastCheck: Date.now(),\r\n\t\t}\r\n\t}\r\n\r\n\tprivate async checkCacheHealth(): Promise<ComponentHealth> {\r\n\t\tconst cacheHits = this.getAggregatedMetrics('cache.hits', Date.now() - 60000)\r\n\t\tconst cacheMisses = this.getAggregatedMetrics('cache.misses', Date.now() - 60000)\r\n\t\tconst totalRequests = cacheHits.sum + cacheMisses.sum\r\n\t\tconst hitRate = totalRequests > 0 ? (cacheHits.sum / totalRequests) * 100 : 85\r\n\r\n\t\tlet score = 100\r\n\t\tif (hitRate < 20)\r\n\t\t\tscore = 60\r\n\t\telse if (hitRate < 40)\r\n\t\t\tscore = 70\r\n\t\telse if (hitRate < 60)\r\n\t\t\tscore = 80\r\n\t\telse if (hitRate < 80)\r\n\t\t\tscore = 90\r\n\r\n\t\treturn {\r\n\t\t\tname: 'cache',\r\n\t\t\tstatus: score >= 60 ? 'healthy' : score >= 40 ? 'degraded' : 'unhealthy',\r\n\t\t\tscore,\r\n\t\t\tmetrics: {\r\n\t\t\t\thitRate,\r\n\t\t\t\thits: cacheHits.sum,\r\n\t\t\t\tmisses: cacheMisses.sum,\r\n\t\t\t},\r\n\t\t\tlastCheck: Date.now(),\r\n\t\t}\r\n\t}\r\n}\r\n"],"names":["process","CorrelationService","Injectable","Logger","ConfigService","MetricType","MonitoringService","_configService","_correlationService","_logger","name","metrics","Map","maxMetricsPerType","config","get","enabled","metricsRetentionMs","alertsRetentionMs","performanceRetentionMs","healthCheckIntervalMs","alertCooldownMs","externalIntegrations","endpoints","startMetricsCleanup","log","recordMetric","value","type","tags","metric","timestamp","Date","now","has","set","metricsList","push","length","splice","debug","correlationId","getCorrelationId","incrementCounter","COUNTER","recordGauge","GAUGE","recordHistogram","HISTOGRAM","recordTimer","durationMs","TIMER","getMetrics","since","filter","m","getMetricNames","Array","from","keys","getAggregatedMetrics","count","sum","avg","min","max","latest","values","map","reduce","a","b","Math","getSystemHealth","components","totalScore","memoryHealth","checkMemoryHealth","diskHealth","checkDiskHealth","networkHealth","checkNetworkHealth","cacheHealth","checkCacheHealth","comp","score","status","overallScore","getStats","totalMetrics","oldestTimestamp","newestTimestamp","metricTypes","_name","entries","avgMetricSize","memoryUsage","oldestMetric","newestMetric","cleanupInterval","setInterval","cleanupOldMetrics","cutoffTime","removedCount","originalLength","filteredMetrics","memUsage","totalMB","heapTotal","usedMB","heapUsed","usagePercent","lastCheck","availableGB","latencyMs","packetsLost","cacheHits","cacheMisses","totalRequests","hitRate","hits","misses"],"mappings":"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"}